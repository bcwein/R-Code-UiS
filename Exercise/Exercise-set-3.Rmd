---
title: "Exercise set 3"
output: pdf_document
author: Bj√∏rn Christian Weinbach
date: 01.09.2020
---

# Exercise 3.3

The Pareto(a, b) distribution has cdf
\begin{equation}
  F(x) = 1 - \frac{b^a}{x^a}
\end{equation}

Derive the probability inverse transformation $F^{-1}(U)$ and use the inverse
transform method to to simulate a random sample from the Pareto(2, 2) dist.

The function $F^{-1}$ is derived by setting $F(X) = U$ and solving for X which
gives us.

\begin{equation}
  U = 1 - \frac{4}{x^2} \implies X = \frac{2}{\sqrt{(1-u)}}
\end{equation}

and this we have $F^{-1}(U) = \frac{2}{\sqrt{(1-u)}}$

and in general terms $F^{-1}(U) = \frac{2}{\sqrt{(1-u)}}$

## Calculate using R

```{r}
simPareto <- function(nSim, a, b) {
  u <- runif(nSim)
  return(b*(1-u)^(-1/a))
}

nSim = 1000000
ParetoFx <- simPareto(nSim = nSim, a = 2, b = 2)
hist(ParetoFx, breaks=30, prob=TRUE)
```


# Exercise 3.5

Use the inverse transform method to generate a random sample of size from
distribution

```{r}
# Alternatively the built in sample function can be used 
## Generating data from the number of heads example where 
## f(0)=1/8, f(1)=3/8, f(2)=3/8 and f(3)=1/8

# Function for simulating number of heads according to the distribution above
discrv <- function(Nsim){
   U <- runif(Nsim)
   X <- rep(0,Nsim)
   X[(U>0.1) & (U<=0.3)] <- 1
   X[(U>0.3) & (U<=0.5)] <- 2
   X[(U>0.5) & (U<=0.7)] <- 3
   X[U>0.7] <- 4
   return(X)
}

Nsim <- 10000

dfx <- discrv(Nsim)
relfreq <- table(dfx)/Nsim
barplot(relfreq,ylab="Relative frequency - Inverse transform method")

# Alternatively the built in sample function can be used 
dfx2 <- sample(0:4,size=Nsim,replace=TRUE,prob=c(0.1,0.2,0.2,0.2,0.3))
relfreq <- table(dfx2)/Nsim
barplot(relfreq,ylab="Relative frequency - Sample method")
```


# Exercise 3.7

Write a function to generate a random sample of size n from the beta(a,b)
distribution by the acceptance-rejection method. Sample size should be
1000 from the beta(3,2) distribution. Graph the sample with the theoretical
Beta(3,2) density.

``` {r}
## Function for acceptance rejection generation
rejectionBeta <- function(a, b, x, n) {
   f <- function(x) (x^(a-1)*(1-x)^(b-1) / beta(a, b))
   g <- function(x) 1
   C <- max(f(x)/g(x))
   
   naccepts <- 0
   result.sample <- rep(NA, n)
   
   while (naccepts < n) {
    y <- runif(1)
    u <- runif(1)
   
    if ( u <= f(y) / (C*g(y)) ) {
      naccepts <- naccepts + 1
      result.sample[naccepts] = y
    }
   }
   
   result.sample
}


# Sequence for x-axis
x <- seq(0, 1, 0.01)
# Sample from distribution
result <- rejection(3, 2, x, 10000)

# Histogram of simulated data with true density on top as red line
hist(result, prob = TRUE,breaks=seq(0,1,length.out=max(10,sqrt(Nsim))),
     main="Histogram of data and true density")
curve(f(x), col = "red", lty = 2, lwd = 2, add = TRUE,xlim=c(0,1))
```

# Exercise 3.17
## a = 3, b = 2

```{r}
Niter <- 1000
Nsim <- 5000

system.time(for (i in 1:Niter)
   rejection(3, 2, x, Nsim))

system.time(for (i in 1:Niter)
   rbeta(Nsim, shape1=3, shape2=2))
```

## a = 1, b = 1

```{r}
Niter <- 1000
Nsim <- 5000

system.time(for (i in 1:Niter)
   rejection(1, 1, x, Nsim))

system.time(for (i in 1:Niter)
   rbeta(Nsim, shape1=1, shape2=1))
```


# Exercise 1

a. Simulate the probability that component 1 and component 2 is working.

```{r}
n <- 10
m <- 10000
mat <- matrix(rbinom(n*m, 1, c(0.7,0.95,0.95,0.95,0.99,0.99,0.92,0.92,0.92,0.7)), n, m)
p <- numeric(4)
p[1] <- sum(mat[2, 0:m] * mat[1, 0:m]) / (2*m)
p[2] <- sum(mat[2, 0:m] + mat[1, 0:m]) / (2*m)
p[3] <- 
p
```

